name: ðŸ“¦ Backup AutomÃ¡tico Alquileres

on:
  # Ejecutar backup el dÃ­a 28 de cada mes a las 23:00 UTC (antes del proceso recurrente)
  schedule:
    - cron: '0 23 28 * *'
  
  # Permitir ejecuciÃ³n manual
  workflow_dispatch:
    inputs:
      includeDetails:
        description: 'Incluir detalles completos (expenses e incomes)'
        required: false
        type: boolean
        default: true

jobs:
  backup-data:
    runs-on: ubuntu-latest
    
    steps:
    - name: ðŸ“¦ InformaciÃ³n del backup
      run: |
        echo "ðŸ“¦ Iniciando backup automÃ¡tico de alquileres"
        echo "ðŸ“… Fecha: $(date)"
        echo "ðŸŒ Timezone: UTC"
        echo "ðŸ’¾ Tipo: Backup completo"
        echo "ðŸ”— API URL: ${{ secrets.ALQUILERES_API_URL }}"

    - name: ðŸ” Verificar conectividad con la API
      run: |
        echo "ðŸ” Verificando que la API estÃ© activa..."
        
        # Intentar conectar al endpoint principal
        HEALTH_RESPONSE=$(curl -s -w "HTTP_STATUS:%{http_code}" \
          -H "User-Agent: GitHub-Backup/1.0" \
          --connect-timeout 30 \
          --max-time 60 \
          "${{ secrets.ALQUILERES_API_URL }}/" || echo "CURL_FAILED")
        
        if [[ "$HEALTH_RESPONSE" == "CURL_FAILED" ]]; then
          echo "âŒ No se puede conectar a la API"
          echo "ðŸ”§ Verificar:"
          echo "   â€¢ URL del secret: ${{ secrets.ALQUILERES_API_URL }}"
          echo "   â€¢ Que Render estÃ© activo"
          echo "   â€¢ Que no haya errores en el servicio"
          exit 1
        fi
        
        HEALTH_STATUS=$(echo "$HEALTH_RESPONSE" | grep -o 'HTTP_STATUS:[0-9]*' | cut -d: -f2)
        echo "ðŸ“Š Status de conectividad: $HEALTH_STATUS"
        
        if [[ "$HEALTH_STATUS" != "200" ]]; then
          echo "âŒ API no responde correctamente (Status: $HEALTH_STATUS)"
          echo "ðŸ”§ Revisar logs de Render"
          exit 1
        fi
        
        echo "âœ… API estÃ¡ activa y respondiendo"

    - name: ðŸ“¥ Realizar backup completo
      run: |
        echo "ðŸ“¥ Descargando backup completo..."
        
        # Configurar parÃ¡metros
        INCLUDE_DETAILS="${{ github.event.inputs.includeDetails || 'true' }}"
        
        # Generar nombre de archivo con timestamp
        TIMESTAMP=$(date +%Y-%m-%d_%H-%M-%S)
        FILENAME="alquileres-backup-$TIMESTAMP.json"
        
        echo "ðŸ“ Archivo: $FILENAME"
        echo "ðŸ“Š Incluir detalles: $INCLUDE_DETAILS"
        
        # Realizar llamada al API de backup con timeout extendido
        HTTP_RESPONSE=$(curl -s -w "HTTP_STATUS:%{http_code}" \
          -H "User-Agent: GitHub-Actions-Backup/1.0" \
          -H "Accept: application/json" \
          --connect-timeout 30 \
          --max-time 300 \
          "${{ secrets.ALQUILERES_API_URL }}/api/backup?includeDetails=$INCLUDE_DETAILS" \
          -o "$FILENAME")
        
        HTTP_STATUS=$(echo "$HTTP_RESPONSE" | grep -o 'HTTP_STATUS:[0-9]*' | cut -d: -f2)
        
        echo "ðŸ“Š HTTP Status: $HTTP_STATUS"
        
        if [[ "$HTTP_STATUS" != "200" ]]; then
          echo "âŒ Error en el backup: HTTP $HTTP_STATUS"
          if [[ -f "$FILENAME" ]]; then
            echo "ðŸ“‹ Contenido de la respuesta:"
            head -20 "$FILENAME"
          fi
          exit 1
        fi
        
        # Verificar que el archivo se descargÃ³
        if [[ -f "$FILENAME" ]]; then
          FILE_SIZE=$(stat -c%s "$FILENAME" 2>/dev/null || stat -f%z "$FILENAME" 2>/dev/null || echo "0")
          echo "âœ… Backup descargado exitosamente"
          echo "ðŸ“Š TamaÃ±o del archivo: $FILE_SIZE bytes"
          
          if [[ "$FILE_SIZE" -lt 100 ]]; then
            echo "âŒ Archivo muy pequeÃ±o, posible error"
            echo "ðŸ“‹ Contenido:"
            cat "$FILENAME"
            exit 1
          fi
          
          # Verificar que es un JSON vÃ¡lido
          if jq '.' "$FILENAME" > /dev/null 2>&1; then
            echo "âœ… JSON vÃ¡lido confirmado"
            
            # Extraer estadÃ­sticas del backup
            PROPERTIES_COUNT=$(jq -r '.stats.properties // 0' "$FILENAME")
            UNITS_COUNT=$(jq -r '.stats.unitsIndependent // 0' "$FILENAME")
            TOTAL_EXPENSES=$(jq -r '.stats.totalExpenses // 0' "$FILENAME")
            TOTAL_INCOMES=$(jq -r '.stats.totalIncomes // 0' "$FILENAME")
            EXPORT_DATE=$(jq -r '.exportDate // "N/A"' "$FILENAME")
            
            echo "ðŸ“Š EstadÃ­sticas del backup:"
            echo "   â€¢ Propiedades: $PROPERTIES_COUNT"
            echo "   â€¢ Unidades independientes: $UNITS_COUNT"
            echo "   â€¢ Total egresos: $TOTAL_EXPENSES"
            echo "   â€¢ Total ingresos: $TOTAL_INCOMES"
            echo "   â€¢ Fecha de exportaciÃ³n: $EXPORT_DATE"
            
            # Guardar nombre del archivo para el siguiente step
            echo "BACKUP_FILENAME=$FILENAME" >> $GITHUB_ENV
            echo "FILE_SIZE_BYTES=$FILE_SIZE" >> $GITHUB_ENV
            echo "PROPERTIES_COUNT=$PROPERTIES_COUNT" >> $GITHUB_ENV
            echo "UNITS_COUNT=$UNITS_COUNT" >> $GITHUB_ENV
            echo "TOTAL_EXPENSES=$TOTAL_EXPENSES" >> $GITHUB_ENV
            echo "TOTAL_INCOMES=$TOTAL_INCOMES" >> $GITHUB_ENV
            
          else
            echo "âŒ Error: El archivo descargado no es un JSON vÃ¡lido"
            echo "ðŸ“‹ Primeras lÃ­neas del archivo:"
            head -20 "$FILENAME"
            exit 1
          fi
          
        else
          echo "âŒ Error: No se pudo descargar el backup"
          exit 1
        fi

    - name: ðŸ’¾ Guardar backup como artifact
      uses: actions/upload-artifact@v4
      with:
        name: backup-alquileres-${{ github.run_number }}
        path: ${{ env.BACKUP_FILENAME }}
        retention-days: 90
        compression-level: 6

    - name: ðŸ” Validar integridad del backup
      run: |
        echo "ðŸ” Validando integridad del backup..."
        
        FILENAME="${{ env.BACKUP_FILENAME }}"
        
        if [[ -f "$FILENAME" ]]; then
          # Verificar estructura bÃ¡sica
          HAS_VERSION=$(jq -r '.version // "missing"' "$FILENAME")
          HAS_EXPORT_DATE=$(jq -r '.exportDate // "missing"' "$FILENAME")
          HAS_STRUCTURE=$(jq -r '.structure // "missing"' "$FILENAME")
          
          echo "ðŸ“‹ VerificaciÃ³n de estructura:"
          echo "   â€¢ Version: $HAS_VERSION"
          echo "   â€¢ Export Date: $HAS_EXPORT_DATE"  
          echo "   â€¢ Structure: $HAS_STRUCTURE"
          
          # Verificar que tiene las secciones principales
          HAS_PROPERTIES=$(jq -r 'has("properties")' "$FILENAME")
          HAS_UNITS=$(jq -r 'has("units")' "$FILENAME")
          HAS_STATS=$(jq -r 'has("stats")' "$FILENAME")
          
          echo "ðŸ“Š VerificaciÃ³n de secciones:"
          echo "   â€¢ Properties: $HAS_PROPERTIES"
          echo "   â€¢ Units: $HAS_UNITS"
          echo "   â€¢ Stats: $HAS_STATS"
          
          if [[ "$HAS_PROPERTIES" == "true" ]] && [[ "$HAS_UNITS" == "true" ]] && [[ "$HAS_STATS" == "true" ]]; then
            echo "âœ… Backup validado exitosamente"
          else
            echo "âŒ Error: Estructura del backup incompleta"
            exit 1
          fi
          
        else
          echo "âŒ Error: No se encontrÃ³ archivo de backup"
          exit 1
        fi

    - name: ðŸ“Š Generar reporte de backup
      if: success()
      run: |
        echo "ðŸ“Š Generando reporte final del backup..."
        
        FILENAME="${{ env.BACKUP_FILENAME }}"
        FILE_SIZE="${{ env.FILE_SIZE_BYTES }}"
        
        # Calcular tamaÃ±o en MB
        FILE_SIZE_MB=$(echo "scale=2; $FILE_SIZE/1024/1024" | bc -l)
        
        # Generar hash MD5
        FILE_HASH=$(md5sum "$FILENAME" | cut -d' ' -f1)
        
        echo "ðŸ“ InformaciÃ³n del archivo:"
        echo "   â€¢ Nombre: $FILENAME"
        echo "   â€¢ TamaÃ±o: $FILE_SIZE_MB MB"
        echo "   â€¢ Hash MD5: $FILE_HASH"
        
        # Crear summary para GitHub
        cat >> $GITHUB_STEP_SUMMARY << EOF
        ## ðŸ“¦ Backup AutomÃ¡tico Completado âœ…
        
        ### ðŸ“ Archivo de Backup
        
        | InformaciÃ³n | Valor |
        |-------------|--------|
        | ðŸ“ Nombre | \`$FILENAME\` |
        | ðŸ“Š TamaÃ±o | $FILE_SIZE_MB MB |
        | ðŸ”’ Hash MD5 | \`$FILE_HASH\` |
        | ðŸ“… Fecha | $(date) |
        
        ### ðŸ“Š Contenido del Backup
        
        | Tipo de Datos | Cantidad |
        |---------------|----------|
        | ðŸ  Propiedades | ${{ env.PROPERTIES_COUNT }} |
        | ðŸ¢ Unidades independientes | ${{ env.UNITS_COUNT }} |
        | ðŸ’¸ Total egresos | ${{ env.TOTAL_EXPENSES }} |
        | ðŸ’° Total ingresos | ${{ env.TOTAL_INCOMES }} |
        
        ### ðŸ’¾ Almacenamiento
        
        - âœ… **Guardado como GitHub Artifact**
        - ðŸ“… **RetenciÃ³n:** 90 dÃ­as
        - ðŸ“¥ **Descarga:** Actions â†’ Artifacts
        - ðŸ—œï¸ **CompresiÃ³n:** Nivel 6
        
        ### ðŸ”§ InformaciÃ³n TÃ©cnica
        - **API Endpoint:** \`GET /api/backup\`
        - **Formato:** JSON
        - **Estructura:** Real (adaptada a Firebase)
        - **Status:** âœ… Validado
        
        ---
        **ðŸ”„ PrÃ³ximo backup automÃ¡tico:** DÃ­a 28 del siguiente mes
        
        EOF

    - name: ðŸ”” NotificaciÃ³n final
      if: always()
      run: |
        if [[ "${{ job.status }}" == "success" ]]; then
          echo "ðŸŽ‰ Backup completado exitosamente"
          echo "âœ… Archivo guardado como GitHub Artifact"
          echo "ðŸ“¥ Para descargar: Actions â†’ Artifacts â†’ backup-alquileres-${{ github.run_number }}"
          echo "ðŸ“… RetenciÃ³n: 90 dÃ­as"
          echo "ðŸ“… PrÃ³ximo backup: 28 del siguiente mes"
        else
          echo "âš ï¸ El backup fallÃ³"
          echo "ðŸ”§ Pasos para resolver:"
          echo "   1. Verificar que la API estÃ© activa en Render"
          echo "   2. Revisar el secret ALQUILERES_API_URL"
          echo "   3. Verificar logs de la API"
          echo "   4. Probar manualmente: ${{ secrets.ALQUILERES_API_URL }}/api/backup"
        fi
        
        echo "ðŸ“‹ Workflow de backup finalizado: $(date)"
